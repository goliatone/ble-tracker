<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Floor plan</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/js/vendors/floorplan/d3.floorplan.css">
</head>
<!-- <script>
    function main() {
        var st = document.getElementById('connection');
        window.st = st;
        var socket = io(window.location.protocol + '//' + window.location.host);
        socket.on('connect', function() {
            console.info('IO => connected');
            st.innerHTML = 'CONNECTED';
            socket.emit('device.ack', {
                uuid: getUUID()
            });
        });

        socket.on('ble.inrange', function(payload) {
            // console.log('IN RANGE');
            var pos = getPosition(payload.beacons);
            // console.log('POS', pos);
            if(isNaN(pos.x) || isNaN(pos.y) || Math.abs(pos.x) === Infinity || Math.abs(pos.y) === Infinity ) return console.warn('OUT', pos);
            pl.refresh([pos]);
        });

        socket.on('device.connected', function(data) {
            console.log('NEW DEVICE CONNECTED', data);
        });
    }

    function getUUID() {
        function makeAndStore() {
            var uuid = makeUUID();
            localStorage.setItem('__uuid__', uuid);
            return uuid;
        }

        function makeUUID() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a, b) {
                return b = Math.random() * 16, (a == "y" ? b & 3 | 8 : b | 0).toString(16)
            });
        }

        return localStorage.getItem('__uuid__') || makeAndStore();
    }


    ///////////
    var geometry = {
        "333::1": {"x":2074, "y":685, "label": "middle-right"},
        "333::2": {"x":1664, "y":51, "label": "top-left"},
        "333::3": {"x":1675, "y":685, "label": "middle-left"},
        "444::1": {"x":1675, "y":1307, "label": "bottom-left"},
        "444::2": {"x":2148, "y":1307, "label": "bottom-right"},
        "444::3": {"x":2125, "y":51, "label": "top-right"}
    };

    function getPosition(beacons){
        if(!beacons) return console.warn('getPosition: No beacons');
        beacons = beacons.sort(function(a, b){
            return a.distance - b.distance;
        });

        var set = beacons.map(function(beacon){
            var point = {};
            point.r = beacon.rssi;
            point.d = beacon.distance * 100;
            point.x = geometry[beacon.major + '::' + beacon.minor].x;
            point.y = geometry[beacon.major + '::' + beacon.minor].y;
            return point;
        });

        return distancePoints(set)[0];

        set = set.slice(0, 3);
        // console.log('ORDER', set)
        // return getTrilateration.apply(null, set);
        return getCoordinate.apply(null, set);
    }

    function getTrilateration(pa, pb, pc) {
        var S = (Math.pow(pc.x, 2.) - Math.pow(pb.x, 2.) + Math.pow(pc.y, 2.) - Math.pow(pb.y, 2.) + Math.pow(pb.r, 2.) - Math.pow(pc.r, 2.)) / 2.0;
        var T = (Math.pow(pa.x, 2.) - Math.pow(pb.x, 2.) + Math.pow(pa.y, 2.) - Math.pow(pb.y, 2.) + Math.pow(pb.r, 2.) - Math.pow(pa.r, 2.)) / 2.0;
        var y = ((T * (pb.x - pc.x)) - (S * (pb.x - pa.x))) / (((pa.y - pb.y) * (pb.x - pb.x)) - ((pc.y - pb.y) * (pb.x - pa.x)));
        var x = ((y * (pa.y - pb.y)) - T) / (pb.x - pa.x);

        return {
            x: x,
            y: y
        };
    }

    getCoordinate(
        {x: 1675, y: 658, d: 3},
        {x: 2074, y: 656, d: 4},
        {x: 1675, y: 1307, d: 3.5}
    );

    function getCoordinate(p1, p2, p3) {
        var w = p1.d * p1.d - p2.d * p2.d - p1.x * p1.x - p1.y * p1.y + p2.x * p2.x + p2.y * p2.y;

        var z = p2.d * p2.d - p3.d * p3.d - p2.x * p2.x - p2.y * p2.y + p3.x * p3.x + p3.y * p3.y;

        var x = (w * (p3.y - p2.y) - z * (p2.y - p1.y)) / (2 * ((p2.x - p1.x) * (p3.y - p2.y) - (p3.x - p2.x) * (p2.y - p1.y)));

        var y = (w - 2 * x * (p2.x - p1.x)) / (2 * (p2.y - p1.y));

        var v = (z - 2 * x * (p3.x - p2.x)) / (2 * (p3.y - p2.y));
        y = (y + v) / 2;

        return {
            x: x,
            y: y
        };
    }


    function Point (x, y) {
        this.x = x;
        this.y = y;
    }

    // function Beacon (x, y, r) {
    //     this.x = x;
    //     this.y = y;
    //     this.d = d;
    // }

    function Midpoint (p1, p2) {
        return new Point(Math.round((p1.x+p2.x)/2), Math.round((p1.y+p2.y)/2));
    }

    function distance (p1, p2) {
        return Math.round(Math.sqrt( (Math.pow(p1.x - p2.x,2)) + (Math.pow(p1.y - p2.y,2)) ));
    }

    function distancePoints (beacons) {

        var points = [], vertices = new Array(beacons.length);

        beacons.forEach(function (beacon, n) {
            vertices[n] = [];
            var _steps = 100, _div = _steps / 2;
            for (var i = 0; i <= _steps; i++) {
                var p = new Point(
                    Math.round(beacon.x + beacon.d * Math.cos((i/_div) * Math.PI)),
                    Math.round(beacon.y + beacon.d * Math.sin((i/_div) * Math.PI))
                );
                vertices[n].push(p);
            }
        });

        // find first two minimal points
        var min = Math.min(); var dist_i = [];
        vertices[0].forEach(function (p1) {
            vertices[1].forEach(function (p2) {
                var dist = distance(p1, p2);
                dist_i.push({midpoint: new Midpoint(p1, p2), dist: dist});
            });
        });

        dist_i = dist_i.sort(function (a, b) { return a.dist - b.dist; });
        var twoPoints = dist_i.slice(0 , 2);

        // check two points against the circle
        var dist_t = [];
        vertices[2].forEach(function (p1) {
            twoPoints.forEach(function (p2) {
                var dist = distance(p1, p2.midpoint);
                dist_t.push({midpoint: new Midpoint(p1, p2.midpoint), dist: dist});
            });
        });

        var p = dist_t
            .sort(function (a,b) { return a.dist - b.dist })
            .map(function (p) { return p.midpoint });
        return p;
    }
</script> -->
<!-- <body onload="main();"> -->
<body>
    <p>Floor Plan</p>
    <div id="connection">
        NOT CONNECTED
    </div>
    <div id="map" />
    <script src="/js/vendors/requirejs/require.js" data-main="/js/boot.js"></script>
</body>
</html>
